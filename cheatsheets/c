# C Cheatsheet
#

C programs rely on three key features:

  1. "Directives"		Editing commands that modify the program prior to compilation (#include statements)
  2. "Functions"		Named blocks of executable code (main)
  3. "Statements"		Commands to be performed when program is run

Variable declarations can be combined:

  int height, length, width, volume; //a whole-number integer up to 2.1 billion
  float profit, loss: 				 //supports decimel point, but float may contain rounding errors!

Declarations must come before Statements; however, C99 allows them to be mixed up (like modern programming)
Append the letter f to Float numbers, i.e: profit = 2150.48f;


Providing a value to a variable for the first time is called an "initializer"; multiple variables may be declared
initializers only apply to one variable (int height, length = 10; does not work)
int height = 8, length = 12, width = 10;

"Wherever a value is needed, any expression of the same type will do."
-C General Principle

"printf" = print formatted (cout)
"scanf"  = read  formatted (cin)
  ("%d", &someVar); 

"Macro Definition": used to name constants; can be an expression
	#define INCHES_PER_POUND 166
	#definte RECIPROCAL_OF_PI (1.0f / 3.14159f)

C will truncate the result when two integers are divided. use float instead:
5.0f / 9.0f

"Identifier"	Variables, functions, macros, etc. 
				Case Sensitive.May contain letters, digits, underscores.
				Must begin with a letter or underscore* 
				*C99 allows for certain universal char. names
				best_practice, alsoBestPractice

C is built on "tokens": groups of chars that can't be split up without changing their meaning
  The following statement has seven tokens, separated by tabs: 
    printf	(	"Height: %d\n"	,	height	)	;

#####################################
# Chapter 3 - Formatted Input/Output
#####################################

"conversion specification"	placeholder representing a value to be filled during print, ie %d
	"%d"   = integer (Decimel base 10)
	"%.1f" = float (display 1 decimel point)
	"%e"   = scientific notation (Exponential format)
	"%s"   = string

	"%m.pX / %-m.pX" (m and p are integer constants and X is a letter)
		"m - minimum field width" 	minimum amount to print
				%3d: "123", " 12", "12345" | %-3d: "123", "12 ", "12345"
		"p - precision"		minimum digits/decimel points to display
				%d = %.1d; %.2d: 22; %.3d: 022;			
				%g: displays a float in either %e or Fixed Decimel, depending on size
					p indicates max number of significant digits to display
				    doesn't show trailing zeros.  will drop decimel point if blank
					dynamic, switches from fixed decimel to exponential when necessary
		"X - conversion specifier"		type: %d, %e, %s, etc. (see above)

"Escape Sequences"
	\a Alert \b Backspace \n New line \t Horizontal Tab \" quotation mark
	%%: prints percent sign

"Scanf under the hood"
	Scanf will initially ignore whitespace/linebreaks during first format string match.
    After first match, it willl continue reading until it reads the first character inconsistent with
    the search string. It is here that whitespace begins to matter, as it is a non-digit character.
    Scanf then drops that from the string, and will add it to the *next* search (very important).
    A second search could attempt to start with an incorrect character if "4abc" is entered as an "int"

	"%d/%d"
	*5/*96 input (* is space) matches 5 to the first. it then drops the slash, uses it in its next match,
	which is a /, so it can continue, then stops at *. it starts at * again, drops the *, and matches 96
	
	*5*/*96 input would match 5 to the first, drop the space...then attempt to match the space to the 
	slash. Unlike conversion specifiers, which ignore beginning whitespace, this would not match, so
	it gets put back. then, */*96 gets run through the second %d, creating bad data. 

	Note: if the second format string was not /, scanf would still start the next match with /, which 
	would generate an error!
 	
